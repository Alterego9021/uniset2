
// --------------------------------------------------------------------------
/*
 DO NOT EDIT THIS FILE. IT IS AUTOGENERATED FILE.
 ALL YOUR CHANGES WILL BE LOST.
 
 НЕ РЕДАКТИРУЙТЕ ЭТОТ ФАЙЛ. ЭТОТ ФАЙЛ СОЗДАН АВТОМАТИЧЕСКИ.
 ВСЕ ВАШИ ИЗМЕНЕНИЯ БУДУТ ПОТЕРЯНЫ.
*/ 
// --------------------------------------------------------------------------
// generate timestamp: 2015-02-28+03:00
// -----------------------------------------------------------------------------
#ifndef UObject_SK_H_
#define UObject_SK_H_
// -----------------------------------------------------------------------------
#include <memory>
#include <string>
#include "UniSetObject.h"
#include "LT_Object.h"
#include "UniXML.h"
#include "Trigger.h"
#include "DebugStream.h"
// -----------------------------------------------------------------------------
class UObject_SK:
	public UniSetObject,
	public LT_Object
{
	public:
		UObject_SK( UniSetTypes::ObjectId id, xmlNode* node=UniSetTypes::uniset_conf()->getNode("UObject"), const std::string& argprefix="" );
		UObject_SK();
		virtual ~UObject_SK();

		
		bool alarm( UniSetTypes::ObjectId sid, bool state );
		long getValue( UniSetTypes::ObjectId sid );
		void setValue( UniSetTypes::ObjectId sid, long value );
		void askSensor( UniSetTypes::ObjectId sid, UniversalIO::UIOCommand, UniSetTypes::ObjectId node = UniSetTypes::uniset_conf()->getLocalNode() );
		void updateValues();
		void setMsg( UniSetTypes::ObjectId code, bool state );

		std::shared_ptr<DebugStream> mylog;
		void init_dlog( std::shared_ptr<DebugStream> d );

        // "синтаксический сахар"..для логов
        #define myinfo if( mylog->debugging(Debug::INFO) ) mylog->info()
        #define mywarn if( mylog->debugging(Debug::WARN) ) mylog->warn()
        #define mycrit if( mylog->debugging(Debug::CRIT) ) mylog->crit()
        #define mylog1 if( mylog->debugging(Debug::LEVEL1) ) mylog->level1()
        #define mylog2 if( mylog->debugging(Debug::LEVEL2) ) mylog->level2()
        #define mylog3 if( mylog->debugging(Debug::LEVEL3) ) mylog->level3()
        #define mylog4 if( mylog->debugging(Debug::LEVEL4) ) mylog->level4()
        #define mylog5 if( mylog->debugging(Debug::LEVEL5) ) mylog->level5()
        #define mylog6 if( mylog->debugging(Debug::LEVEL6) ) mylog->level6()
        #define mylog7 if( mylog->debugging(Debug::LEVEL7) ) mylog->level7()
        #define mylog8 if( mylog->debugging(Debug::LEVEL8) ) mylog->level8()
        #define mylog9 if( mylog->debugging(Debug::LEVEL9) ) mylog->level9()
        #define mylogany mylog->any()


		// Используемые идентификаторы
		

		// Используемые идентификаторы сообщений
		

		// Текущее значение
		

		// --- public variables ---
		
		
		// --- end of public variables ---

	protected:
		// --- protected variables ---
		
		
		// ---- end of protected variables ----

		
		virtual void callback() override;
		virtual void processingMessage( UniSetTypes::VoidMessage* msg ) override;
		virtual void sysCommand( const UniSetTypes::SystemMessage* sm ) override;
		virtual void askSensors( UniversalIO::UIOCommand cmd ){}
		virtual void sensorInfo( const UniSetTypes::SensorMessage* sm ) override{}
		virtual void timerInfo( const UniSetTypes::TimerMessage* tm ) override{}
		virtual void sigterm( int signo ) override;
		virtual bool activateObject() override;
		virtual void testMode( bool state );
		void updatePreviousValues();
		void checkSensors();
		void updateOutputs( bool force );

		void preAskSensors( UniversalIO::UIOCommand cmd );
		void preSensorInfo( const UniSetTypes::SensorMessage* sm );
		void preTimerInfo( const UniSetTypes::TimerMessage* tm );
		void waitSM( int wait_msec, UniSetTypes::ObjectId testID = UniSetTypes::DefaultObjectId );

		void resetMsg();
		Trigger trResetMsg;
		PassiveTimer ptResetMsg;
		int resetMsgTime;

		// Выполнение очередного шага программы
		virtual void step(){}

		int sleep_msec; /*!< пауза между итерациями */
		bool active;

		const std::string argprefix;
		UniSetTypes::ObjectId smTestID; /*!< идентификатор датчика для тестирования готовности SM */

		// управление датчиком "сердцебиения"
		PassiveTimer ptHeartBeat;				/*! < период "сердцебиения" */
		UniSetTypes::ObjectId idHeartBeat;		/*! < идентификатор датчика (AI) "сердцебиения" */
		int maxHeartBeat;						/*! < сохраняемое значение */
		
		xmlNode* confnode;
		/*! получить числовое свойство из конф. файла по привязанной confnode */
		int getIntProp(const std::string& name) { return UniSetTypes::uniset_conf()->getIntProp(confnode, name); }
		/*! получить текстовое свойство из конф. файла по привязанной confnode */
		inline const std::string getProp(const std::string& name) { return UniSetTypes::uniset_conf()->getProp(confnode, name); }

		int smReadyTimeout; 	/*!< время ожидания готовности SM */
		std::atomic_bool activated;
		int activateTimeout;	/*!< время ожидания готовности UniSetObject к работе */
		PassiveTimer ptStartUpTimeout;	/*!< время на блокировку обработки WatchDog, если недавно был StartUp */
		int askPause; /*!< пауза между неудачными попытками заказать датчики */
		
		IOController_i::SensorInfo si;
		bool forceOut; /*!< флаг принудительного обноления "выходов" */


	private:
		
		// --- private variables ---
		// --- end of private variables ---

		// предыдущее значение (для работы UpdateValue())
		

		// Используемые идентификаторы сообщений
		

		bool end_private; // вспомогательное поле (для внутреннего использования при генерировании кода)
};

// -----------------------------------------------------------------------------
#endif // UObject_SK_H_
