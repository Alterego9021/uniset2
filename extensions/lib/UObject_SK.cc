
// Метод с использованием заказа датчиков
// --------------------------------------------------------------------------

// --------------------------------------------------------------------------
/*
 DO NOT EDIT THIS FILE. IT IS AUTOGENERATED FILE.
 ALL YOUR CHANGES WILL BE LOST.

 НЕ РЕДАКТИРУЙТЕ ЭТОТ ФАЙЛ. ЭТОТ ФАЙЛ СОЗДАН АВТОМАТИЧЕСКИ.
 ВСЕ ВАШИ ИЗМЕНЕНИЯ БУДУТ ПОТЕРЯНЫ.
*/
// --------------------------------------------------------------------------
// generate timestamp: 2013-12-10+04:00
// -----------------------------------------------------------------------------
#include "Configuration.h"
#include "Exceptions.h"
#include "UObject_SK.h"

// -----------------------------------------------------------------------------
using namespace std;
using namespace UniSetTypes;
// -----------------------------------------------------------------------------

// --------------------------------------------------------------------------

// -----------------------------------------------------------------------------
UObject_SK::UObject_SK():
// Инициализация идентификаторов (имена берутся из конф. файла)

// Используемые идентификаторы сообщений (имена берутся из конф. файла)

// variables

active(false),

idHeartBeat(DefaultObjectId),
maxHeartBeat(10),
confnode(0),
smReadyTimeout(0),
activated(false),
askPause(2000),

end_private(false)
{
	unideb[Debug::CRIT] << "UObject: init failed!!!!!!!!!!!!!!!" << endl;
	throw Exception( string(myname+": init failed!!!") );
}
// -----------------------------------------------------------------------------
// ( val, confval, default val )
static const std::string init3_str( const std::string& s1, const std::string& s2, const std::string& s3 )
{
	if( !s1.empty() )
		return s1;
	if( !s2.empty() )
		return s2;

	return s3;
}
// -----------------------------------------------------------------------------
UObject_SK::UObject_SK( ObjectId id, xmlNode* cnode, const std::string& argprefix ):
UniSetObject(id),
// Инициализация идентификаторов (имена берутся из конф. файла)

// Используемые идентификаторы сообщений (имена берутся из конф. файла)

// variables

sleep_msec(150),
active(true),

idHeartBeat(DefaultObjectId),
maxHeartBeat(10),
confnode(cnode),
smReadyTimeout(0),
activated(false),
askPause(conf->getPIntProp(cnode,"askPause",2000)),

end_private(false)
{

	if( UniSetTypes::findArgParam("--print-id-list",conf->getArgc(),conf->getArgv()) != -1 )
	{

//		abort();
	}


	if( getId() == DefaultObjectId )
	{
		ostringstream err;
		err << "(UObject::init): Unknown ObjectID!";
		throw SystemError( err.str() );
	}



	UniXML_iterator it(cnode);
	string heart = conf->getArgParam("--heartbeat-id",it.getProp("heartbeat_id"));
	if( !heart.empty() )
	{
		idHeartBeat = conf->getSensorID(heart);
		if( idHeartBeat == DefaultObjectId )
		{
			ostringstream err;
			err << myname << ": не найден идентификатор для датчика 'HeartBeat' " << heart;
			throw SystemError(err.str());
		}

		int heartbeatTime = conf->getArgPInt("--heartbeat-time",it.getProp("heartbeatTime"),conf->getHeartBeatTime());
		if( heartbeatTime>0 )
			ptHeartBeat.setTiming(heartbeatTime);
		else
			ptHeartBeat.setTiming(UniSetTimer::WaitUpTime);

		maxHeartBeat = conf->getArgPInt("--heartbeat-max",it.getProp("heartbeat_max"), 10);
	}

	// Инициализация значений


	sleep_msec = conf->getArgPInt("--sleep-msec","150", 150);

	resetMsgTime = conf->getPIntProp(cnode,"resetMsgTime", 2000);
	ptResetMsg.setTiming(resetMsgTime);

	smReadyTimeout = conf->getArgInt("--sm-ready-timeout","");
	if( smReadyTimeout == 0 )
		smReadyTimeout = 60000;
	else if( smReadyTimeout < 0 )
		smReadyTimeout = UniSetTimer::WaitUpTime;

	std::string tmp_smtestID("");

	smTestID = conf->getSensorID(init3_str(conf->getArgParam("--" + argprefix + "sm-test-id"),conf->getProp(cnode,"smTestID"),tmp_smtestID));

	activateTimeout	= conf->getArgPInt("--activate-timeout", 20000);

	int msec = conf->getArgPInt("--startup-timeout", 10000);
	ptStartUpTimeout.setTiming(msec);

	// ===================== <variables> =====================

	// ===================== end of <variables> =====================
}

// -----------------------------------------------------------------------------

UObject_SK::~UObject_SK()
{
}
// -----------------------------------------------------------------------------
void UObject_SK::updateValues()
{
	// Опрашиваем все входы...

}
// -----------------------------------------------------------------------------
void UObject_SK::updatePreviousValues()
{

}
// -----------------------------------------------------------------------------
void UObject_SK::checkSensors()
{

}
// -----------------------------------------------------------------------------
bool UObject_SK::alarm( UniSetTypes::ObjectId _code, bool _state )
{
	if( _code == UniSetTypes::DefaultObjectId )
	{
		unideb[Debug::CRIT]  << getName()
							<< "(alarm): попытка послать сообщение с DefaultObjectId" 
							<< endl;
		return false;	
	}

	unideb[Debug::LEVEL1]  << getName()  << "(alarm): ";
	if( _state )
		unideb(Debug::LEVEL1) << "SEND ";
	else
		unideb(Debug::LEVEL1) << "RESET ";
	
	unideb(Debug::LEVEL1) << endl;
	
	

	unideb[Debug::LEVEL1] << " not found MessgeOID?!!" << endl;
	return false;
}
// -----------------------------------------------------------------------------
void UObject_SK::resetMsg()
{
// reset messages

}
// -----------------------------------------------------------------------------
void UObject_SK::testMode( bool _state )
{
	if( !_state  )
		return;

	// отключаем все выходы

}
// -----------------------------------------------------------------------------

// --------------------------------------------------------------------------

// ------------------------------------------------------------------------------------------
void UObject_SK::init_dlog( DebugStream& d )
{
	UObject_SK::dlog = d;
}
// ------------------------------------------------------------------------------------------
void UObject_SK::processingMessage( UniSetTypes::VoidMessage* _msg )
{
	try
	{
		switch( _msg->type )
		{
			case Message::SensorInfo:
			{
				SensorMessage _sm( _msg );
				preSensorInfo( &_sm );
				break;
			}

			case Message::Timer:
			{
				TimerMessage _tm(_msg);
				preTimerInfo(&_tm);
				break;
			}

			case Message::SysCommand:
			{
				SystemMessage _sm( _msg );
				sysCommand( &_sm );
				break;
			}

			default:
				break;
		}	
	}
	catch(Exception& ex)
	{
		cout  << myname << "(processingMessage): " << ex << endl;
	}
}
// -----------------------------------------------------------------------------
void UObject_SK::sysCommand( SystemMessage* _sm )
{
	switch( _sm->command )
	{
		case SystemMessage::WatchDog:
			unideb << myname << "(sysCommand): WatchDog" << endl;
			if( !active || !ptStartUpTimeout.checkTime() )
			{
				unideb[Debug::WARN] << myname << "(sysCommand): игнорируем WatchDog, потому-что только-что стартанули" << endl;
				break;
			}
		case SystemMessage::StartUp:
		{
			waitSM(smReadyTimeout);
			ptStartUpTimeout.reset();
			// т.к. для io-переменных важно соблюдать последовательность!
			// сперва обновить входы.. а потом уже выходы
			updateValues();
			updateOutputs(true); // принудительное обновление выходов
			preAskSensors(UniversalIO::UIONotify);
			askSensors(UniversalIO::UIONotify);
			active = true;
			break;
		}

		case SystemMessage::FoldUp:
		case SystemMessage::Finish:
			preAskSensors(UniversalIO::UIODontNotify);
			askSensors(UniversalIO::UIODontNotify);
			break;

		case SystemMessage::LogRotate:
		{
			// переоткрываем логи
			unideb << myname << "(sysCommand): logRotate" << endl;
			string fname = unideb.getLogFile();
			if( !fname.empty() )
			{
				unideb.logFile(fname.c_str());
				unideb << myname << "(sysCommand): ***************** UNIDEB LOG ROTATE *****************" << endl;
			}
		}
		break;

		default:
			break;
	}
}
// -----------------------------------------------------------------------------
void UObject_SK::setState( UniSetTypes::ObjectId _sid, bool _state )
{
	setValue(_sid, _state ? 1 : 0 );
}
// -----------------------------------------------------------------------------

void UObject_SK::sigterm( int signo )
{
	UniSetObject::sigterm(signo);
	active = false;
}
// -----------------------------------------------------------------------------
bool UObject_SK::activateObject()
{
	// блокирование обработки Startup 
	// пока не пройдёт инициализация датчиков
	// см. sysCommand()
	{
		activated = false;
		UniSetObject::activateObject();
		activated = true;
	}

	return true;
}
// -----------------------------------------------------------------------------
void UObject_SK::preTimerInfo( UniSetTypes::TimerMessage* _tm )
{
	timerInfo(_tm);
}
// ----------------------------------------------------------------------------
void UObject_SK::waitSM( int wait_msec, ObjectId _testID )
{


	if( _testID == DefaultObjectId )
		_testID = smTestID;

	if( _testID == DefaultObjectId )
		return;

	if( unideb.debugging(Debug::INFO) )
	{
		unideb[Debug::INFO] << myname << "(waitSM): waiting SM ready "
			<< wait_msec << " msec"
			<< " testID=" << _testID << endl;
	}

	if( !ui.waitReady(_testID,wait_msec) )
	{
		ostringstream err;
		err << myname 
			<< "(waitSM): Не дождались готовности(exist) SharedMemory к работе в течение " 
			<< wait_msec << " мсек";

		unideb[Debug::CRIT] << err.str() << endl;
		terminate();
		abort();
		// kill(SIGTERM,getpid());	// прерываем (перезапускаем) процесс...
		throw SystemError(err.str());
	}


}
// ----------------------------------------------------------------------------

// --------------------------------------------------------------------------
void UObject_SK::callback()
{
	if( !active )
		return;
	try
	{

		// проверка таймеров
		checkTimers(this);

		if( resetMsgTime>0 && trResetMsg.hi(ptResetMsg.checkTime()) )
		{
//			cout << myname <<  ": ********* reset messages *********" << endl;
			resetMsg();
		}

		// обработка сообщений (таймеров и т.п.)
		for( int i=0; i<20; i++ )
		{
			if( !receiveMessage(msg) )
				break;
			processingMessage(&msg);
			updateOutputs(false);
//			updatePreviousValues();
		}

		// Выполнение шага программы
		step();

		// "сердцебиение"
		if( idHeartBeat!=DefaultObjectId && ptHeartBeat.checkTime() )
		{
			ui.saveValue(idHeartBeat,maxHeartBeat,UniversalIO::AnalogInput);
			ptHeartBeat.reset();
		}

		// обновление выходов
		updateOutputs(false);
		updatePreviousValues();
	}
	catch( Exception& ex )
	{
		unideb[Debug::CRIT] << myname << "(execute): " << ex << endl;
	}
	catch(CORBA::SystemException& ex)
	{
		unideb[Debug::CRIT] << myname << "(execute): СORBA::SystemException: "
			<< ex.NP_minorString() << endl;
	}
	catch(...)
	{
		unideb[Debug::CRIT] << myname << "(execute): catch ..." << endl;
	}

	if( !active )
		return;
	
	msleep( sleep_msec );
}
// -----------------------------------------------------------------------------
void UObject_SK::setValue( UniSetTypes::ObjectId _sid, long _val )
{
//	ui.setState(sid,state);

}
// -----------------------------------------------------------------------------
void UObject_SK::updateOutputs( bool _force )
{

}
// -----------------------------------------------------------------------------
void UObject_SK::preSensorInfo( UniSetTypes::SensorMessage* _sm )
{


	sensorInfo(_sm);
}
// -----------------------------------------------------------------------------
void UObject_SK::askState( UniSetTypes::ObjectId _sid, UniversalIO::UIOCommand _cmd, UniSetTypes::ObjectId _node )
{
	ui.askRemoteSensor(_sid,_cmd,_node,getId());
}
// -----------------------------------------------------------------------------
void UObject_SK::askValue( UniSetTypes::ObjectId _sid, UniversalIO::UIOCommand _cmd, UniSetTypes::ObjectId _node )
{
	ui.askRemoteSensor(_sid,_cmd,_node,getId());
}
// -----------------------------------------------------------------------------
bool UObject_SK::getState( UniSetTypes::ObjectId _sid )
{
	return (bool)getValue(_sid);
}
// -----------------------------------------------------------------------------
long UObject_SK::getValue( UniSetTypes::ObjectId _sid )
{
	try
	{

		unideb[Debug::CRIT] << myname << "(getState): Обращение к неизвестному ДИСКРЕТНОМУ датчику sid="
			<< _sid << endl;
	}
	catch(Exception& ex)
	{
		unideb[Debug::CRIT] << myname << "(getState): " << ex << endl;
		throw;
	}

	return 0;
}
// -----------------------------------------------------------------------------

void UObject_SK::preAskSensors( UniversalIO::UIOCommand _cmd )
{
	PassiveTimer ptAct(activateTimeout);
	while( !activated && !ptAct.checkTime() )
	{	
		cout << myname << "(preAskSensors): wait activate..." << endl;
		msleep(300);
		if( activated )
			break;
	}
			
	if( !activated )
		unideb[Debug::CRIT] << myname
			<< "(preAskSensors): ************* don`t activated?! ************" << endl;

	for( ;; )
	{
		try
		{

			return;
		}
		catch(SystemError& err)
		{
			unideb[Debug::CRIT] << myname << "(preAskSensors): " << err << endl;
		}
		catch(Exception& ex)
		{
			unideb[Debug::CRIT] << myname << "(preAskSensors): " << ex << endl;
		}
		catch(...)
		{
			unideb[Debug::CRIT] << myname << "(preAskSensors): catch(...)" << endl;
		}
		msleep(askPause);
	}
}
// -----------------------------------------------------------------------------
void UObject_SK::setMsg( UniSetTypes::ObjectId _code, bool _state )
{
	// блокируем сброс (т.к. он автоматически по таймеру)
	if( !_state )
	{
		ptResetMsg.reset();
		return;
	}

	alarm( _code, _state );
	ptResetMsg.reset();
}	
// ----------------------------------------------------------------------------
