- сделать, чтобы можно было Debug пускать через syslog (да ещё и на другую машину)

- Подумать и реализовать механизм хранения ссылок (IOR) с использованием разделяемой памяти...
(сейчас есть IORFile и omniNames). // нужно ли

- (IONotifyController): Разработать механизм заказа переодических уведомлений (msec), независимо от того, менялись ли датчики..
- (IONotifyController): Разработать механизм заказа группы датчиков сразу (и ответ тоже группой)

----------
codegen:
- Сделать работу с TestMode на основе заказа! 
- Сделать работу с ResetMsg на основе askTimer! // подумать нужно ли..


Version 2.0
============
- циклическое хранилище для аварийных следов на основе SQLite
- сделать MultiChannelSlave (слушает несколько каналов, но в SM сохраняет данные
только от одного, при пропаже связи переключается на другой и т.д. по кругу)

// --- Оптимизация.. --- //
   - сделать ли ObjectId short?
   - "продумать" функцию key()... может наложить ограничение на диапазон id..


- depend_invert - возможность инвертировать логику, т.е. задать не "разрешающий датчик", а "запрещающий" (для механизма который на уровне SharedMemory)

- uniset-codegen:  сделать в src.xml <description> и генерировать на его основе описание класса

- уйти по возможности на стандартные исключения.. вместо Exceptions..
- использовать везде где нужно(и можно) вместо прямых указателей.. shared_ptr и т.п. (например для conf и других глобальных переменных)
- встроить различные сигналы (sigc).. в ModbusExchange и другие классы..

- uniset-codegen: дописать функцию help со всеми параметрами для _SK, тесты
- uniset-codegen: добавить в генерируемую документацию значения по умолчанию..

- unetudp: добавить возмоность привязать номера текущего посылаемого и принимаемого пакетов к датчику


- ТЕСТЫ! ТЕСТЫ! ТЕСТЫ!


- Перевести взаимодействие PassiveObject <--> ProxyManager на shared_ptr (или weak_ptr).

uniset-codegen:  добавить ключ --gen-sensor-name для генерирования name_Item.. (чтобы можно было в логах использовать текстовые названия)

- перевести PassiveTimer на использование crono:: (c++11)

Version 2.1
============
- smonit запись значений в файл (csv?,sqlite?)
- python: gui sensor monitor 

- IOBase: возможность задавать свою формулу преобразования входного сигнала (помимо калибровки)..

- переписать систему инициализации и работы между UniSetActivator,UniSetManager и UniSetObject-ами
(уменьшить количество функций (связность) и определится кто отвечает за удаление объекта и т.п.)




version 3
=========
Перепроектировать классы [ObjectRepository, UInterface, ORepHelpers] с целью выработки абстрактного интерфейса
UResolver (или ObjectRepository) позволяющего манипулировать CORBA-ссылками на объекты, но по возможности 
скрывающими детали "CORBA-кухни". Чтобы можно было "хранилище" реализовать на базе СУБД, SQLite, ,файлов и т.п.
Примерно интерфейс должен уметь следующее:
- resgister(name)
- unregister(name)
- resolve(name)
- resolve(name,node) // обращение к IResolver удалённого узла..
- create(rootname)

- вместо commoncpp,libxml2,DebugStream и т.п. перейти всё-таки на boost?

